## Exercício 1
a)  Eu Concordo, Pois é mais fácil repetir números e descobrir a chave.

b)
```
import { v4 } from "uuid";
export function generateId(): string {
    return v4();
  }
```

## Exercício 2
a) O código cria a conexão do banco de dados,guardado o registro  na constante connection. A função createUser insere um novo usuário na tabela userTableName.

b) 
```
CREATE TABLE users_aula50(
	id VARCHAR(255) NOT NULL PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL
)
```

c) 
Query:
```
export const insertUser = async (
    id: string,
    email:string,
    password: string
    ):Promise<void> => {
    try {
        await connection('users_aula50')
        .insert({
            id,
            email,
            password
        })
    } catch (error) {
        throw new Error(error.message || error.sqlMessage);
    }
}
```

Endpoint:
```
export const createUser = async (
    req:Request, 
    res: Response
    ) => {
    
    const { email, password } = req.body
    let message = 'User has been created.'
    try {
        if(!email || !password) {
            res.statusCode = 406
            message = 'Missing "name" and/or "password".'
            throw new Error(message);
        }
        const id: string = generateId()
        await insertUser(
            id,
            email,
            password
        )
        res.status(201).send({
            message: message
        })
    } catch (error) {
        res.status(400).send({
            message: error.message || error.sqlMessage
        })
    }
}
```

c) Transforma em string o parametro , que é aceito pelo argument Secret do sign().

d)
```
export type AuthenticationData = {
    id: string
}
export const generateToken = (
    payload: string
): string => {
    return jwt.sign(
        payload,
        process.env.JWT_KEY as string,
        {
            expiresIn: process.env.JWT_EXPIRES_IN
        }
    )
}
```

## Exercício 4

a)
```
export const createUser = async (
    req:Request, 
    res: Response
    ) => {
    
    const { email, password } = req.body
    let message = 'Token has been generated by jwt.'
    
    try {
        if(!email || !password) {
            res.statusCode = 406
            message = 'Missing "name" and/or "password".'
            throw new Error(message);
        }
        
        const id: string = generateId()
        
        await insertUser(
            id,
            email,
            password
            )
            
        res.status(201).send({
            message: message
        })
    } catch (error) {
        res.status(400).send({
            message: error.message || error.sqlMessage
        })
    }
}
```

## Exercício 5

a)
```
export const selectUserByEmail = async (
    email:string
    ): Promise<User> => {
    try {
        const result = await connection('users_aula50')
        .select('*')
        .where({
            email
        })
        return {
            id: result[0].id,
            email: result[0].email,
            password: result[0].password
        }
    } catch (error) {
        throw new Error(error.message || error.sqlMessage);
    }
}
```

## Exercício 6

```
export const login = async (
    req: Request,
    res:Response
    ) => {
    
    const { email, password } = req.body
    let message: string = 'User is loged.'
    try {
        if(!email || !email.includes('@')){
            res.statusCode = 400
            message = 'Invalid email.'
            throw new Error(message);
        }
        
        const user: User | undefined = await selectUserByEmail(email)
        
        if(!user){
            res.statusCode = 404
            message = "User not found or wrong password."
            throw new Error(message);
        }
        
        if(user.password !== password){
            res.statusCode = 401
            message = "User not found or wrong password."
            throw new Error(message);
        }
        const token: string = generateToken({
            id: user.id
        })
        res.send({
            message,
            token: token
        })
    } catch (error) {
        res.status(400).send({
            message: error.message || error.sqlMessage
        })
    }
}
```

## Exercício 7

a) faz com que a key seja de todos os formatos, fazendo assim não ter um formado expecifico

b)
```
export const getTokenData = (
    token: string
): AuthenticationData => {
    return jwt.verify(
        token,
        process.env.JWT_KEY as string
    ) as AuthenticationData
}
```

## Exercício 8

a)
```
export const selectUserById = async (
    id: string
): Promise<User> => {
    try {
    const result = await connection('users_aula50')
    .select('*')
    .where({
        id
    })
    return {
        id: result[0].id,
        email: result[0].email,
        password: result[0].password
    }
    } catch (error) {
        throw new Error(error.message || error.sqlMessage);
    }
}
```

b)
```
export const getUserProfile = async (
    req: Request, 
    res: Response
    ) => {
    
    let message = 'User found!'
    const token: string = req.headers.authorization as string
    const tokenData: AuthenticationData = getTokenData(token)
    try {
    
        const userData = await selectUserById(tokenData.id)
        if(!userData){
            res.statusCode = 404
            message = 'User not found!'
            throw new Error(message);
        }
        res.status(200).send({
            message: {
                id: userData.id,
                email: userData.email
            }
        })
    } catch (error) {
        res.status(400).send({
            message: error.message || error.sqlMessage
        })    
    }
}
```